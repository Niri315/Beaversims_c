// Beaversims.Tools/G​enerators/ConvertDataFiles.cs
using System.Globalization;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Beaversims.Tools.Generators
{
    internal static class ConvertDataFiles
    {
        public static void ConvertRandPropPointsToCs(
            string inputPath, string outputPath, string csNamespace /* = "Beaversims.Core.Data.Dbc" */)
        {
            var text = File.ReadAllText(inputPath);

            var regex = new Regex(
                @"\{\s*(\d+)\s*,\s*([\-0-9.eE]+)f\s*,\s*([\-0-9.eE]+)f\s*,\s*\{([^}]*)\}\s*,\s*\{([^}]*)\}\s*,\s*\{([^}]*)\}\s*\}",
                RegexOptions.Compiled | RegexOptions.Multiline);

            float ParseF(string s) =>
                float.Parse(s.Replace("f", "").Trim(), NumberStyles.Float, CultureInfo.InvariantCulture);

            float[] ParseArr(string s) =>
                s.Split(',', StringSplitOptions.RemoveEmptyEntries).Select(x => ParseF(x)).ToArray();

            var rows = new List<(int ilvl, float drs, float ds, float[] e, float[] r, float[] u)>();
            foreach (Match m in regex.Matches(text))
            {
                var ilvl = int.Parse(m.Groups[1].Value, CultureInfo.InvariantCulture);
                var drs = ParseF(m.Groups[2].Value);
                var ds = ParseF(m.Groups[3].Value);
                var e = ParseArr(m.Groups[4].Value);
                var r = ParseArr(m.Groups[5].Value);
                var u = ParseArr(m.Groups[6].Value);
                if (e.Length != 5 || r.Length != 5 || u.Length != 5)
                    throw new InvalidDataException($"Row {ilvl} does not have 5 values per tier.");
                rows.Add((ilvl, drs, ds, e, r, u));
            }

            string F(float v) => v.ToString("0.########", CultureInfo.InvariantCulture) + "f";

            var sb = new StringBuilder(1024 * 1024);
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// Generated by Beaversims.Tools.Generators.ConvertDataFiles");
            sb.AppendLine("// DO NOT EDIT MANUALLY.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine($"namespace {csNamespace};");
            sb.AppendLine();
            // Only emit the data container; the struct already exists in another file.
            sb.AppendLine("internal static partial class RandomPropPoints");
            sb.AppendLine("{");
            sb.AppendLine("    internal static readonly RandomPropData[] Data = new RandomPropData[]");
            sb.AppendLine("    {");

            foreach (var r in rows)
            {
                sb.Append("        new RandomPropData(");
                sb.Append($"{r.ilvl}, {F(r.drs)}, {F(r.ds)}, ");
                sb.Append($"{F(r.e[0])}, {F(r.e[1])}, {F(r.e[2])}, {F(r.e[3])}, {F(r.e[4])}, ");
                sb.Append($"{F(r.r[0])}, {F(r.r[1])}, {F(r.r[2])}, {F(r.r[3])}, {F(r.r[4])}, ");
                sb.Append($"{F(r.u[0])}, {F(r.u[1])}, {F(r.u[2])}, {F(r.u[3])}, {F(r.u[4])}");
                sb.AppendLine("),");
            }

            sb.AppendLine("    };");
            sb.AppendLine("}");

            Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
            File.WriteAllText(outputPath, sb.ToString());
        }



        public static void ConvertJsonItems(string inputFlatJson, string outputJson)
        {
            var json = File.ReadAllText(inputFlatJson);
            using var doc = JsonDocument.Parse(json);
            var root = doc.RootElement;
            if (root.ValueKind != JsonValueKind.Array)
                throw new InvalidDataException("Expected top-level array.");

            // map name -> best (highest-id) element
            var bestMap = new Dictionary<string, JsonElement>(StringComparer.OrdinalIgnoreCase);

            foreach (var it in root.EnumerateArray())
            {
                if (!it.TryGetProperty("name", out var np) || np.GetString() is not { Length: > 0 } name)
                    continue;

                int id = it.TryGetProperty("id", out var idProp) && idProp.TryGetInt32(out var val) ? val : 0;

                if (!bestMap.TryGetValue(name, out var existing))
                {
                    bestMap[name] = it.Clone();
                }
                else
                {
                    int existingId = existing.TryGetProperty("id", out var eidProp) && eidProp.TryGetInt32(out var eid) ? eid : 0;
                    if (id > existingId)
                        bestMap[name] = it.Clone(); // keep higher id
                }
            }

            // sort by name and serialize back
            var sorted = bestMap
                .OrderBy(k => k.Key, StringComparer.OrdinalIgnoreCase)
                .ToDictionary(k => k.Key, k => k.Value, StringComparer.OrdinalIgnoreCase);

            var options = new JsonSerializerOptions { WriteIndented = true };
            File.WriteAllText(outputJson, JsonSerializer.Serialize(sorted, options));
        }

        public static void ConvertScScaleDataToCs(
       string inputPath, string outputPath, string csNamespace /* = "Beaversims.Core.Data.Dbc" */)
        {
            var text = File.ReadAllText(inputPath);

            // --- Regexes (non-overlapping) ---
            // 2D:  static constexpr double __foo[][N] = { { ... }, { ... } };
            var rx2D = new Regex(
                @"static\s+constexpr\s+(float|double)\s+([A-Za-z0-9_]+)\s*\[\s*\]\s*\[\s*\d+\s*\]\s*=\s*\{(?<body>.*?)\};",
                RegexOptions.Singleline | RegexOptions.Compiled);

            // 1D:  static constexpr double __bar[N] = { ... };
            var rx1D = new Regex(
                @"static\s+constexpr\s+(float|double)\s+([A-Za-z0-9_]+)\s*\[\s*\d+\s*\]\s*=\s*\{(?<body>.*?)\};",
                RegexOptions.Singleline | RegexOptions.Compiled);

            static string CleanName(string name)
            {
                name = name.TrimStart('_');
                // PascalCase by underscores
                var parts = name.Split(new[] { '_' }, StringSplitOptions.RemoveEmptyEntries);
                return string.Concat(parts.Select(p => char.ToUpperInvariant(p[0]) + p.Substring(1)));
            }

            static string StripComments(string s)
            {
                // remove // comments and compress whitespace/newlines
                s = Regex.Replace(s, @"//.*?$", "", RegexOptions.Multiline);
                s = s.Replace("\r", "").Trim();
                return s;
            }

            var emitted = new HashSet<string>(StringComparer.Ordinal);
            var sb = new StringBuilder(1024 * 1024);

            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// Generated by Beaversims.Tools.Generators.ConvertDataFiles");
            sb.AppendLine("// DO NOT EDIT MANUALLY.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine($"namespace {csNamespace};");
            sb.AppendLine();
            sb.AppendLine("internal static partial class ScScaleData");
            sb.AppendLine("{");

            // ------ 2D arrays first ------
            foreach (Match m in rx2D.Matches(text))
            {
                var elemType = m.Groups[1].Value; // "float" or "double"
                var rawName = m.Groups[2].Value;
                var name = CleanName(rawName);
                if (!emitted.Add(name)) continue;

                var body = StripComments(m.Groups["body"].Value);

                // Split { ... } rows
                var rows = Regex.Matches(body, @"\{([^}]*)\}")
                                .Cast<Match>()
                                .Select(mm => mm.Groups[1].Value.Trim())
                                .Where(x => x.Length > 0)
                                .ToArray();

                var csElemType = elemType == "float" ? "float" : "double";

                sb.AppendLine($"    public static readonly {csElemType}[][] {name} = new {csElemType}[][]");
                sb.AppendLine("    {");
                foreach (var row in rows)
                {
                    var cleanedRow = StripComments(row);
                    sb.AppendLine($"        new {csElemType}[] {{ {cleanedRow} }},");
                }
                sb.AppendLine("    };");
                sb.AppendLine();
            }

            // ------ 1D arrays (skip any already emitted by 2D pass) ------
            foreach (Match m in rx1D.Matches(text))
            {
                var elemType = m.Groups[1].Value; // "float" or "double"
                var rawName = m.Groups[2].Value;
                var name = CleanName(rawName);
                if (!emitted.Add(name)) continue; // avoid duplicates

                var content = StripComments(m.Groups["body"].Value)
                    .Replace("\n", "")
                    .Trim();

                var csElemType = elemType == "float" ? "float" : "double";

                sb.AppendLine($"    public static readonly {csElemType}[] {name} = new {csElemType}[] {{ {content} }};");
                sb.AppendLine();
            }

            sb.AppendLine("}");

            Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
            File.WriteAllText(outputPath, sb.ToString());
            Console.WriteLine($"Generated {outputPath}");
        }

    }

}