// Beaversims.Tools/G​enerators/ConvertDataFiles.cs
using System.Globalization;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace Beaversims.Tools.Generators
{
    internal static class ConvertDataFiles
    {
        public static void ConvertRandPropPointsToCs(
            string inputPath, string outputPath, string csNamespace /* = "Beaversims.Core.Data.Dbc" */)
        {
            var text = File.ReadAllText(inputPath);

            var regex = new Regex(
                @"\{\s*(\d+)\s*,\s*([\-0-9.eE]+)f\s*,\s*([\-0-9.eE]+)f\s*,\s*\{([^}]*)\}\s*,\s*\{([^}]*)\}\s*,\s*\{([^}]*)\}\s*\}",
                RegexOptions.Compiled | RegexOptions.Multiline);

            float ParseF(string s) =>
                float.Parse(s.Replace("f", "").Trim(), NumberStyles.Float, CultureInfo.InvariantCulture);

            float[] ParseArr(string s) =>
                s.Split(',', StringSplitOptions.RemoveEmptyEntries).Select(x => ParseF(x)).ToArray();

            var rows = new List<(int ilvl, float drs, float ds, float[] e, float[] r, float[] u)>();
            foreach (Match m in regex.Matches(text))
            {
                var ilvl = int.Parse(m.Groups[1].Value, CultureInfo.InvariantCulture);
                var drs = ParseF(m.Groups[2].Value);
                var ds = ParseF(m.Groups[3].Value);
                var e = ParseArr(m.Groups[4].Value);
                var r = ParseArr(m.Groups[5].Value);
                var u = ParseArr(m.Groups[6].Value);
                if (e.Length != 5 || r.Length != 5 || u.Length != 5)
                    throw new InvalidDataException($"Row {ilvl} does not have 5 values per tier.");
                rows.Add((ilvl, drs, ds, e, r, u));
            }

            string F(float v) => v.ToString("0.########", CultureInfo.InvariantCulture) + "f";

            var sb = new StringBuilder(1024 * 1024);
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// Generated by Beaversims.Tools.Generators.ConvertDataFiles");
            sb.AppendLine("// DO NOT EDIT MANUALLY.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine($"namespace {csNamespace};");
            sb.AppendLine();
            // Only emit the data container; the struct already exists in another file.
            sb.AppendLine("internal static partial class RandomPropPoints");
            sb.AppendLine("{");
            sb.AppendLine("    internal static readonly RandomPropData[] Data = new RandomPropData[]");
            sb.AppendLine("    {");

            foreach (var r in rows)
            {
                sb.Append("        new RandomPropData(");
                sb.Append($"{r.ilvl}, {F(r.drs)}, {F(r.ds)}, ");
                sb.Append($"{F(r.e[0])}, {F(r.e[1])}, {F(r.e[2])}, {F(r.e[3])}, {F(r.e[4])}, ");
                sb.Append($"{F(r.r[0])}, {F(r.r[1])}, {F(r.r[2])}, {F(r.r[3])}, {F(r.r[4])}, ");
                sb.Append($"{F(r.u[0])}, {F(r.u[1])}, {F(r.u[2])}, {F(r.u[3])}, {F(r.u[4])}");
                sb.AppendLine("),");
            }

            sb.AppendLine("    };");
            sb.AppendLine("}");

            Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
            File.WriteAllText(outputPath, sb.ToString());
        }

        public static void ConvertItemDataJson_ToCs(string inputPath, string outputPath, string csNamespace)
        {
            // --- read json once ---
            using var doc = JsonDocument.Parse(File.ReadAllText(inputPath));
            var root = doc.RootElement;
            if (root.ValueKind != JsonValueKind.Array)
                throw new InvalidDataException("Top-level JSON must be an array of items.");

            // ---------- helpers (define ONCE) ----------
            static string Q(string s)
                => "\"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"";

            static string GetStringSafe(JsonElement obj, string name, string @default = "")
                => obj.TryGetProperty(name, out var p) && p.ValueKind == JsonValueKind.String
                    ? (p.GetString() ?? @default) : @default;

            static int GetIntSafe(JsonElement obj, string name, int @default = 0)
                => obj.TryGetProperty(name, out var p) && p.TryGetInt32(out var v) ? v : @default;

            static bool GetBoolSafe(JsonElement obj, string name, bool @default = false)
                => obj.TryGetProperty(name, out var p)
                    ? p.ValueKind == JsonValueKind.True ? true :
                      p.ValueKind == JsonValueKind.False ? false : @default
                    : @default;

            static string SocketTypesLiteral(JsonElement item)
            {
                if (item.TryGetProperty("socketInfo", out var si) &&
                    si.TryGetProperty("sockets", out var sockets) &&
                    sockets.ValueKind == JsonValueKind.Array)
                {
                    var types = sockets.EnumerateArray()
                        .Select(x => x.TryGetProperty("type", out var t) ? (t.GetString() ?? "") : "")
                        .Where(t => !string.IsNullOrEmpty(t))
                        .ToArray();

                    if (types.Length > 0)
                        return "new string[] { " + string.Join(", ", types.Select(Q)) + " }";
                }
                return "Array.Empty<string>()";
            }

            static string StatsLiteral(JsonElement item)
            {
                if (item.TryGetProperty("stats", out var arr) && arr.ValueKind == JsonValueKind.Array)
                {
                    var pairs = arr.EnumerateArray()
                        .Select(s => (HasId: s.TryGetProperty("id", out var idp) && idp.TryGetInt32(out var _),
                                      HasAlloc: s.TryGetProperty("alloc", out var alp) && alp.TryGetInt32(out var _),
                                      Id: s.TryGetProperty("id", out var idp2) && idp2.TryGetInt32(out var idv) ? idv : 0,
                                      Alloc: s.TryGetProperty("alloc", out var alp2) && alp2.TryGetInt32(out var alv) ? alv : 0))
                        .Where(t => t.HasId || t.HasAlloc)
                        .Select(t => $"({t.Id}, {t.Alloc})")
                        .ToArray();

                    if (pairs.Length > 0)
                        return "new (int,int)[] { " + string.Join(", ", pairs) + " }";
                }
                return "Array.Empty<(int,int)>()";
            }

            // track duplicate names to avoid duplicate keys in the generated initializer
            var seenNames = new HashSet<string>(StringComparer.Ordinal);

            // ---------- build the .cs file ----------
            var sb = new StringBuilder(1024 * 1024);
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// Generated by Beaversims.Tools — DO NOT EDIT MANUALLY.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine($"namespace {csNamespace};");
            sb.AppendLine();
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine("internal static partial class ItemDatabase");
            sb.AppendLine("{");
            sb.AppendLine("    internal static readonly Dictionary<string, ItemData> ByName = new()");
            sb.AppendLine("    {");

            foreach (var item in root.EnumerateArray())
            {
                // required-ish
                var name = GetStringSafe(item, "name", "");
                if (string.IsNullOrWhiteSpace(name))
                    continue; // skip nameless entries

                // ensure unique key (append ID if duplicate name)
                var key = name;
                var id = GetIntSafe(item, "id");
                if (!seenNames.Add(key))
                {
                    key = $"{name} ({id})";
                    seenNames.Add(key);
                }

                var icon = GetStringSafe(item, "icon", "");
                var quality = GetIntSafe(item, "quality");
                var itemClass = GetIntSafe(item, "itemClass");
                var itemSubClass = GetIntSafe(item, "itemSubClass");
                var inventoryType = GetIntSafe(item, "inventoryType");
                var itemLevel = GetIntSafe(item, "itemLevel");
                var expansion = GetIntSafe(item, "expansion");
                var hasSockets = GetBoolSafe(item, "hasSockets");

                var socketLiteral = SocketTypesLiteral(item);
                var statsLiteral = StatsLiteral(item);

                sb.AppendLine(
                    $"        [{Q(key)}] = new ItemData({id}, {Q(name)}, {Q(icon)}, {quality}, {itemClass}, {itemSubClass}, {inventoryType}, {itemLevel}, {expansion}, {hasSockets.ToString().ToLower()}, {socketLiteral}, {statsLiteral}),");
            }

            sb.AppendLine("    };");
            sb.AppendLine("}");

            Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
            File.WriteAllText(outputPath, sb.ToString());
        }
    }
}